#!/usr/bin/env bash
set -euo pipefail
. $PLUGIN_DIR/.ecs-support

#------------------------------------------------------------
on-activate() {
  if hasEcsFiles && hasLoadBalancerRules
  then
    return $PLUGIN_ENABLED
  fi
  return $PLUGIN_DISABLED
}

hasLoadBalancerRules() {
  if [ "${#DU_LOAD_BALANCER_RULES[@]}" == 0 ]; then return 1; fi
  return 0;
}


#------------------------------------------------------------
on-initialize() {
  checkExposedService
  updateDockerCompose
  updateEcsParams
}

checkExposedService() {
  if [ -z "${DU_ECS_EXPOSE_SERVICE:-}" ]
  then
    abort "DU_ECS_EXPOSE_SERVICE is not defined in product conf"
  fi
  local port=
  port=$(docker-compose-editor exposed-port -i $ECS_DOCKER_COMPOSE_FILE -s $DU_ECS_EXPOSE_SERVICE)
  if [ -z "$port" ]
  then
    abort "Service $ECS_DOCKER_COMPOSE_FILE does not appear to be mapped to a port"
  fi
}

#------------------------------------------------------------
on-validate() {
  if [ -z "$(albHealthCheckPath)" ]
  then
    abort "Niether LOAD_BALANCER_HEALTH_CHECK_PATH or DU_HEALTH_CHECK_PATH is defined"
  fi
}

albHealthCheckPath() {
  echo "${LOAD_BALANCER_HEALTH_CHECK_PATH:-${DU_HEALTH_CHECK_PATH:-}}"
}


#------------------------------------------------------------
on-deploy-green() {
  local tgArn
  tgArn=$(createNewTargetGroup)
  save "new-tg-arn" "$tgArn"
  echo "Target group $tgArn"
  echo "Target group health check $(albHealthCheckPath)"
  replaceAlbRulesOnGreen \
    $GREEN_LOAD_BALANCER_PROTOCOL \
    $GREEN_LOAD_BALANCER_NAME \
    $GREEN_LOAD_BALANCER_PORT \
    "$tgArn"
  deployService $tgArn
  waitToBeHealthy \
    $GREEN_LOAD_BALANCER_PROTOCOL \
    $GREEN_LOAD_BALANCER_NAME \
    $GREEN_LOAD_BALANCER_PORT \
  return 0
}

replaceAlbRulesOnGreen() {
  local protocol=$1
  local alb=$2
  local port=$3
  local tgArn=$4
  echo "Replacing ALB rules on ${alb} for ${protocol} protocol on port ${port}"
  for priority in ${!DU_LOAD_BALANCER_RULES[@]}
  do
    local path="${DU_LOAD_BALANCER_RULES[$priority]}"
    alb replace-rule \
      --name $alb \
      --protocol $protocol \
      --port $port \
      --path "$path" \
      --target-group $tgArn \
      --min-priority $priority \
      --output $WORK/ecs-green-rule
    jq -r '.Rules[].RuleArn' $WORK/ecs-green-rule >> $WORK/ecs-green-rules

  done
}

waitToBeHealthy() {
  local protocol=$1
  local alb=$2
  local port=$3
  for path in ${DU_LOAD_BALANCER_RULES[@]}
  do
    if ! alb rule-health \
      --name $alb \
      --protocol $protocol \
      --port $port \
      --path "$path" \
      --wait 180
    then
      echo "Service was previously healthy but load balancer rules are not."
      echo "Target group health check is configured as $(albHealthCheckPath)"
      echo "Have your health checks changed?"
      abortUnlessForced "Timeout waiting for healthy target groups ($(albHealthCheckPath))"
    fi
  done
}

#------------------------------------------------------------
on-switch-to-blue() {
  local tgArn
  tgArn=$(recall "new-tg-arn")
  removeNewRules green
  addAlbRulesOnBlue \
    $BLUE_LOAD_BALANCER_PROTOCOL \
    $BLUE_LOAD_BALANCER_NAME \
    $BLUE_LOAD_BALANCER_PORT \
    "$tgArn"
  return 0
}

removeNewRules() {
  local color="$1"
  if [ -f $WORK/ecs-$color-rules ]
  then
    echo "Deleting new $color rules..."
    echo "Rules" > $ECS_DEBUG
    local failed=false
    while read arn
    do
      echo "Deleting $arn"
      if ! aws elbv2 delete-rule --rule-arn $arn 2>&1 | tee -a $ECS_DEBUG
      then
        failed=true
      fi
    done < $WORK/ecs-$color-rules
    if [ $failed != false -o "${DEBUG:-}" == true ]
    then
      cat $ECS_DEBUG
      return 1
    fi
  fi
  sleep 2
}

addAlbRulesOnBlue() {
  local protocol=$1
  local alb=$2
  local port=$3
  local tgArn=$4
  echo "Adding ALB rules on ${alb} for ${protocol} protocol on port ${port}"
  for priority in ${!DU_LOAD_BALANCER_RULES[@]}
  do
    local path="${DU_LOAD_BALANCER_RULES[$priority]}"
    alb rule-details \
      --name $alb \
      --protocol $protocol \
      --port $port \
      --path "$path" \
      | jq -r '[.RuleArn,.Priority]|join(" ")' \
      >> $WORK/ecs-existing-rules
  done

  for priority in ${!DU_LOAD_BALANCER_RULES[@]}
  do
    local path="${DU_LOAD_BALANCER_RULES[$priority]}"
    alb add-rule \
      --name $alb \
      --protocol $protocol \
      --port $port \
      --path "$path" \
      --target-group $tgArn \
      --min-priority $priority \
      --output $WORK/ecs-blue-rule
    jq -r '.Rules[].RuleArn' $WORK/ecs-blue-rule >> $WORK/ecs-blue-rules
  done

  if [ -f $WORK/ecs-existing-rules ]
  then
    echo "Deprioritizing old rules"
    local maxPriority
    maxPriority=$(alb rule-summary -n $alb --port $port --protocol $protocol \
      | awk 'BEGIN {max=2000} /^[0-9]/ {if ($1 > max) max=$1} END {print max}')
    local priorities
    while read arn priority
    do
      if [ "$priority" -lt 2000 ]
      then
        maxPriority=$(($maxPriority + 1))
        priorities+="RuleArn=$arn,Priority=$maxPriority "
        echo "Moving $arn from slot $priority to $maxPriority"
      fi
    done < $WORK/ecs-existing-rules
    if [ -n "${priorities:-}" ]
    then
      if ! aws elbv2 set-rule-priorities --rule-priorities $priorities --output text 2>&1 > $ECS_DEBUG
      then
        cat $ECS_DEBUG
        return 1
      fi
    fi
  fi
}


#------------------------------------------------------------
# TODO
on-after-verify-blue() {
  removeOldRules
  removeTargetGroup old
  removeServices old
  removeTaskDefinition old
  return 0
}

removeOldRules() {
  if [ -f $WORK/ecs-existing-rules ]
  then
    echo "Deleting old rules..."
    echo "Rules" > $ECS_DEBUG
    local failed=false
    while read arn priority
    do
      echo "Deleting $arn"
      if ! aws elbv2 delete-rule --rule-arn $arn 2>&1 >> $ECS_DEBUG
      then
        failed=true
      fi
    done < $WORK/ecs-existing-rules
    if [ $failed != false ]
    then
      cat $ECS_DEBUG
      return 1
    fi
  fi
}



#------------------------------------------------------------
# TODO
on-rollback() {
  rollbackOldRules
  removeNewRules blue
  removeNewRules green
  removeTargetGroup new
  removeServices new
  removeTaskDefinition new
  return 0
}

rollbackOldRules() {
  echo "Rolling back rule changes..."
  if [ -f $WORK/ecs-existing-rules ]
  then
    echo "Reprioritizing old rules"
    local priorities
    while read arn priority
    do
      priorities+="RuleArn=$arn,Priority=$priority "
      echo "Moving $arn back to slot $priority"
    done < $WORK/ecs-existing-rules
    if ! aws elbv2 set-rule-priorities --rule-priorities $priorities --output text 2>&1 > $ECS_DEBUG
    then
      echo "FAILED TO ROLLBACK RULES"
      cat $ECS_DEBUG
      return 1
    fi
  fi
}

createNewTargetGroup() {
  local targetGroupName= containerPort= tgArn=
  targetGroupName=$(tgName)
  containerPort=$(docker-compose-editor exposed-port \
    --in $ECS_DOCKER_COMPOSE_FILE \
    --service $DU_ECS_EXPOSE_SERVICE)
  aws elbv2 create-target-group \
    --vpc-id $(vpc id-for-environment -e $VPC) \
    --name $targetGroupName \
    --port $containerPort \
    --target-type ip \
    --protocol HTTP \
    --health-check-protocol HTTP \
    --health-check-port traffic-port \
    --health-check-enabled \
    --health-check-interval-seconds 30 \
    --health-check-timeout-seconds 5 \
    --healthy-threshold-count 3 \
    --unhealthy-threshold-count 3 \
    --health-check-path "$(albHealthCheckPath)" \
    --matcher HttpCode=200 \
    > $WORK/$targetGroupName
  tgArn=$(jq -r '.TargetGroups[].TargetGroupArn' $WORK/$targetGroupName)
  echo $tgArn
}


main "$@"
exit 1
